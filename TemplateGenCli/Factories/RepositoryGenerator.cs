using System.Text;
using TemplateGenCli.Interfaces;
using TemplateGenCli.Models;

namespace TemplateGenCli.Factories;
public class RepositoryGenerator : IGenerator
{
    public void Run(IGeneratorConfig config, GeneratorContext context)
    {
        var repoConfig = (RepositoryConfig)config;
        var entityConfig = context.EntityConfig;

        if (!Directory.Exists(entityConfig.Path))
        {
            Console.WriteLine($"Entities path not found: {entityConfig.Path}");
            return;
        }

        Directory.CreateDirectory(repoConfig.OutputPath);
        Directory.CreateDirectory(repoConfig.InterfaceOutput);

        if (entityConfig.ExceptEntities.Any(e => e.Contains(" ")))
        {
            Console.WriteLine("Warning: Entity exclusion list may contain invalid names. Make sure they match exact entity class names.");
        }
        var excluded = new HashSet<string>(
          entityConfig.ExceptEntities ?? Enumerable.Empty<string>(),
          StringComparer.OrdinalIgnoreCase
      );
        var entityFiles = Directory.GetFiles(entityConfig.Path, "*.cs")
                     .Select(Path.GetFileNameWithoutExtension)
                     .Where(name => !string.IsNullOrEmpty(name) && !excluded.Contains(name))
                     .ToList();

        if (entityFiles.Count == 0)
        {
            Console.WriteLine("No entity files found.");
            return;
        }

        var newInjectLines = new List<string>();
        foreach (var file in entityFiles)
        {
            var entityName = Path.GetFileNameWithoutExtension(file);
            if (string.IsNullOrEmpty(entityName))
            {
                Console.WriteLine($"Skipping empty file: {file}");
                continue;
            }
            var interfaceName = $"I{entityName}Repository";
            var className = $"{entityName}Repository";

            // 1. Interface
            var interfacePath = Path.Combine(repoConfig.InterfaceOutput, $"{interfaceName}.cs");
            if (!File.Exists(interfacePath))
            {
                var interfaceCode = GenerateInterfaceCode(entityName, repoConfig, context);
                File.WriteAllText(interfacePath, interfaceCode, Encoding.UTF8);
                Console.WriteLine($"Created: {interfacePath}");
            }

            // 2. Implementation
            var implPath = Path.Combine(repoConfig.OutputPath, $"{className}.cs");
            if (!File.Exists(implPath))
            {
                var implCode = GenerateImplCode(entityName, repoConfig, context);
                File.WriteAllText(implPath, implCode, Encoding.UTF8);
                Console.WriteLine($"Created: {implPath}");
            }

            // 3. DI Line
            var injectLine = $"        services.AddScoped<{interfaceName}, {className}>();";
            newInjectLines.Add(injectLine);
        }

        InjectToDIFile(repoConfig.DiFilePath, newInjectLines, repoConfig.StartMark, repoConfig.EndMark);
    }

    private string GenerateInterfaceCode(string entity, RepositoryConfig config, GeneratorContext context) => $@"using {context.EntityConfig.Namespace};

namespace {config.InterfaceNamespace};

// <auto-generated />
public interface I{entity}Repository : IRepositoryBase<{entity}>
{{
    // Define custom methods if needed
}}";

    private string GenerateImplCode(string entity, RepositoryConfig config, GeneratorContext context) => $@"using Microsoft.EntityFrameworkCore;
using {context.EntityConfig.Namespace};
using {config.PersistenceNamespace};
using {config.InterfaceNamespace};

namespace {config.Namespace};

// <auto-generated />
public class {entity}Repository({config.DbContext} _db) : RepositoryBase<{entity}>(_db), I{entity}Repository
{{
    private IQueryable<{entity}> BaseQuery(bool asNoTracking = false)
    {{
        var query = _db.Set<{entity}>();
        return asNoTracking ? query.AsNoTracking() : query;
    }}  
    // Implement the method
    #region VM Method
    #endregion
    //Rewrite the GetAllAsync method
    protected override Task<IQueryable<{entity}>> BuildQueryAsync()
    {{
       //Default query no action
        return Task.FromResult(_db.Set<{entity}>().AsQueryable());

        // Do you query here
        // var query = _db.TableNames.AsNoTracking();
        // return Task.FromResult(query);    
     }}

    //Rewrite the GetWithIncludesAsync method
    protected override Task<IQueryable<{entity}>> BuildQueryWithIncludesAsync()
    {{
        //Default query no action
        return Task.FromResult(_db.Set<{entity}>().AsQueryable());

        // Do you query here
        // var query = _db.TableNames.AsNoTracking();
        // return Task.FromResult(query);    
    }}

     //Rewrite the GetSingleAsync method
    protected override Task<IQueryable<{entity}>> BuildGetByIdQueryAsync()
    {{
        //Default query no action
        return Task.FromResult(_db.Set<{entity}>().AsQueryable());

        // Do you query here
        // var query = _db.TableNames;
        // return Task.FromResult(query);    
    }}

    //Add the method that want to perform before delete the entity
    protected override async Task BeforeRemove({entity} entity)
    {{
    //Do you logic here
    }}

    //Add the method that want to perform before add the entity
    protected override async Task BeforeAdd({entity} entity)
    {{
        //Do you logic here
    }}

    //Add the method that want to perform before update the entity
    protected override async Task BeforeUpdate({entity} entity)
    {{
        //Do you logic here
    }}
}}";

    private void InjectToDIFile(string filePath, List<string> injectLines, string startMark, string endMark)
    {
        if (!File.Exists(filePath))
        {
            Console.WriteLine($@"DI file not found: {filePath}

Please add:

{startMark}
{endMark}

inside your method for Dependency Injection registration.");
            return;
        }

        var lines = File.ReadAllLines(filePath).ToList();
        var start = lines.FindIndex(l => l.Contains(startMark));
        var end = lines.FindIndex(l => l.Contains(endMark));

        if (start < 0 || end <= start)
        {
            Console.WriteLine($"DI injection markers not found: {startMark} ~ {endMark}");
            return;
        }

        var existing = lines
            .Skip(start + 1)
            .Take(end - start - 1)
            .Where(l => l.Trim().StartsWith("services.AddScoped"))
            .ToList();

        var existingPairs = existing
          .Select(l => l.Trim())
          .Where(l => l.StartsWith("services.AddScoped"))
          .Select(l =>
          {
              // 尝试从类似 services.AddScoped<IX, Y>() 提取 IX 和 Y
              var parts = l.Split(new[] { '<', '>', ',' }, StringSplitOptions.RemoveEmptyEntries);
              return parts.Length >= 3
                  ? (Interface: parts[1].Trim().Split('.').Last(), Impl: parts[2].Trim().Split('.').Last())
                  : default;
          })
          .Where(p => !string.IsNullOrEmpty(p.Interface) && !string.IsNullOrEmpty(p.Impl))
          .ToHashSet();

        var merged = existing
            .Concat(injectLines.Where(line =>
            {
                var parts = line.Split(new[] { '<', '>', ',' }, StringSplitOptions.RemoveEmptyEntries);
                if (parts.Length < 3) return false;

                var iface = parts[1].Trim().Split('.').Last();
                var impl = parts[2].Trim().Split('.').Last();

                return !existingPairs.Contains((iface, impl));
            }))
            .Distinct()
            .OrderBy(l => l)
            .ToList();

        lines.RemoveRange(start + 1, end - start - 1);
        lines.InsertRange(start + 1, merged);
        File.WriteAllLines(filePath, lines);

        Console.WriteLine($"Injected {injectLines.Count} repositories into DI file.");
    }
}
