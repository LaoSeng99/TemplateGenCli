using System.Text;
using TemplateGenCli.Extensions;
using TemplateGenCli.Interfaces;
using TemplateGenCli.Models;

namespace TemplateGenCli.Factories;
public class RepositoryGenerator : IGenerator
{
    public void Run(IGeneratorConfig config, GeneratorContext context)
    {
        var repoConfig = (RepositoryConfig)config;
        var entityConfig = context.EntityConfig;
        var structureConfig = context.StructureConfig;
        var oriNamespace = repoConfig.Namespace;
        var oriInterfacesNamespace = repoConfig.InterfaceNamespace;

        if (!Directory.Exists(entityConfig.Path))
        {
            Console.WriteLine($"Entities path not found: {entityConfig.Path}");
            return;
        }

        Directory.CreateDirectory(repoConfig.OutputPath);
        Directory.CreateDirectory(repoConfig.InterfaceOutput);

        var entityFiles = entityConfig.Path.GetEntitiesFilePath(entityConfig.ExceptEntities);
        if (entityFiles.Count == 0)
        {
            Console.WriteLine("No entity files found.");
            return;
        }

        var newInjectLines = new List<string>();
        foreach (var file in entityFiles)
        {
            var entityName = Path.GetFileNameWithoutExtension(file);
            if (string.IsNullOrEmpty(entityName) || string.IsNullOrEmpty(file))
            {
                Console.WriteLine($"Skipping empty file: {file}");
                continue;
            }

            var interfaceName = $"I{entityName}Repository";
            var className = $"{entityName}Repository";

            string modularName = "";
            if (structureConfig.Enable)
            {
                modularName = file.GetModularName(structureConfig.ModularAttributeName);
                if (string.IsNullOrEmpty(modularName))
                {
                    Console.WriteLine($"Modular name not found in file: {file}");
                }
                else
                {
                    repoConfig.Namespace = $"{oriNamespace}.{modularName}";
                    repoConfig.InterfaceNamespace = $"{oriInterfacesNamespace}.{modularName}";

                    if (structureConfig.RepoInterfaceModular)
                    {
                        var path = Path.Combine(repoConfig.InterfaceOutput, modularName);
                        Directory.CreateDirectory(path);
                    }

                    if (structureConfig.RepoImplModular)
                    {
                        var path = Path.Combine(repoConfig.OutputPath, modularName);
                        Directory.CreateDirectory(path);
                    }
                }
            }

            // 1. Interface
            var interfacePath = Path.Combine(
                repoConfig.InterfaceOutput,
                structureConfig.RepoInterfaceModular ? modularName : "",
                $"{interfaceName}.cs"
                );

            if (!File.Exists(interfacePath))
            {
                var interfaceCode = GenerateInterfaceCode(entityName, repoConfig, context);
                File.WriteAllText(interfacePath, interfaceCode, Encoding.UTF8);
                Console.WriteLine($"Created: {interfacePath}");
            }

            // 2. Implementation
            var implPath = Path.Combine(
                repoConfig.OutputPath,
                structureConfig.RepoInterfaceModular ? modularName : "",
                $"{className}.cs"
                );

            if (!File.Exists(implPath))
            {
                var implCode = GenerateImplCode(entityName, repoConfig, context);
                File.WriteAllText(implPath, implCode, Encoding.UTF8);
                Console.WriteLine($"Created: {implPath}");
            }

            // 3. DI Line
            var injectLine = $"        services.AddScoped<{interfaceName}, {className}>();";
            newInjectLines.Add(injectLine);
        }

        InjectToDIFile(repoConfig.DiFilePath, newInjectLines, repoConfig.StartMark, repoConfig.EndMark);
    }

    private string GenerateInterfaceCode(string entity, RepositoryConfig config, GeneratorContext context) => $@"using {context.EntityConfig.Namespace};

namespace {config.InterfaceNamespace};

// <auto-generated />
public interface I{entity}Repository : IRepositoryBase<{entity}>
{{
    // Define custom methods if needed
}}";

    private string GenerateImplCode(string entity, RepositoryConfig config, GeneratorContext context) => $@"using Microsoft.EntityFrameworkCore;
using {context.EntityConfig.Namespace};
using {config.PersistenceNamespace};
using {config.InterfaceNamespace};

namespace {config.Namespace};

// <auto-generated />
public class {entity}Repository({config.DbContext} _db) : RepositoryBase<{entity}>(_db), I{entity}Repository
{{
    private IQueryable<{entity}> BaseQuery(bool asNoTracking = false)
    {{
        var query = _db.Set<{entity}>();
        return asNoTracking ? query.AsNoTracking() : query;
    }}  
    // Implement the method
}}";

    private void InjectToDIFile(string filePath, List<string> injectLines, string startMark, string endMark)
    {
        if (!File.Exists(filePath))
        {
            Console.WriteLine($@"DI file not found: {filePath}

Please add:

{startMark}
{endMark}

inside your method for Dependency Injection registration.");
            return;
        }

        var lines = File.ReadAllLines(filePath).ToList();
        var start = lines.FindIndex(l => l.Contains(startMark));
        var end = lines.FindIndex(l => l.Contains(endMark));

        if (start < 0 || end <= start)
        {
            Console.WriteLine($"DI injection markers not found: {startMark} ~ {endMark}");
            return;
        }

        var existing = lines
            .Skip(start + 1)
            .Take(end - start - 1)
            .Where(l => l.Trim().StartsWith("services.AddScoped"))
            .ToList();

        var existingPairs = existing
          .Select(l => l.Trim())
          .Where(l => l.StartsWith("services.AddScoped"))
          .Select(l =>
          {
              // 尝试从类似 services.AddScoped<IX, Y>() 提取 IX 和 Y
              var parts = l.Split(new[] { '<', '>', ',' }, StringSplitOptions.RemoveEmptyEntries);
              return parts.Length >= 3
                  ? (Interface: parts[1].Trim().Split('.').Last(), Impl: parts[2].Trim().Split('.').Last())
                  : default;
          })
          .Where(p => !string.IsNullOrEmpty(p.Interface) && !string.IsNullOrEmpty(p.Impl))
          .ToHashSet();

        var merged = existing
            .Concat(injectLines.Where(line =>
            {
                var parts = line.Split(new[] { '<', '>', ',' }, StringSplitOptions.RemoveEmptyEntries);
                if (parts.Length < 3) return false;

                var iface = parts[1].Trim().Split('.').Last();
                var impl = parts[2].Trim().Split('.').Last();

                return !existingPairs.Contains((iface, impl));
            }))
            .Distinct()
            .OrderBy(l => l)
            .ToList();

        lines.RemoveRange(start + 1, end - start - 1);
        lines.InsertRange(start + 1, merged);
        File.WriteAllLines(filePath, lines);

        Console.WriteLine($"Injected {injectLines.Count} repositories into DI file.");
    }
}
