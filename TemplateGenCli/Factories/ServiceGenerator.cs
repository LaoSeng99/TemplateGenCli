using System.Text;
using TemplateGenCli.Interfaces;
using TemplateGenCli.Models;

namespace TemplateGenCli.Factories;
public class ServiceGenerator : IGenerator
{
    public void Run(IGeneratorConfig config, GeneratorContext context)
    {
        var svcConfig = (ServiceConfig)config;
        var entityConfig = context.EntityConfig;

        if (!Directory.Exists(entityConfig.Path))
        {
            Console.WriteLine($"Entities path not found: {entityConfig.Path}");
            return;
        }

        Directory.CreateDirectory(svcConfig.OutputPath);
        Directory.CreateDirectory(svcConfig.InterfaceOutput);

        var excluded = new HashSet<string>(
          entityConfig.ExceptEntities ?? Enumerable.Empty<string>(),
          StringComparer.OrdinalIgnoreCase
      );
        var entityFiles = Directory.GetFiles(entityConfig.Path, "*.cs")
                                   .Select(Path.GetFileNameWithoutExtension)
                                   .Where(name => !string.IsNullOrEmpty(name) && !excluded.Contains(name))
                                   .ToList();

        if (entityFiles.Count == 0)
        {
            Console.WriteLine("No valid entity files found.");
            return;
        }

        var newInjectLines = new List<string>();

        foreach (var file in entityFiles)
        {
            var entityName = Path.GetFileNameWithoutExtension(file);
            if (string.IsNullOrEmpty(entityName))
            {
                Console.WriteLine($"Skipping empty file: {file}");
                continue;
            }

            var interfaceName = $"I{entityName}Service";
            var className = $"{entityName}Service";

            // 1. Interface
            var interfacePath = Path.Combine(svcConfig.InterfaceOutput, $"{interfaceName}.cs");
            if (!File.Exists(interfacePath))
            {
                var code = GenerateInterfaceCode(entityName, svcConfig);
                File.WriteAllText(interfacePath, code, Encoding.UTF8);
                Console.WriteLine($"Created: {interfacePath}");
            }

            // 2. Implementation
            var implPath = Path.Combine(svcConfig.OutputPath, $"{className}.cs");
            if (!File.Exists(implPath))
            {
                var code = GenerateImplCode(entityName, svcConfig);
                File.WriteAllText(implPath, code, Encoding.UTF8);
                Console.WriteLine($"Created: {implPath}");
            }

            // 3. DI Line
            newInjectLines.Add($"        services.AddScoped<{interfaceName}, {className}>();");
        }

        InjectToDIFile(svcConfig.DiFilePath, newInjectLines, svcConfig.StartMark, svcConfig.EndMark);
    }

    private string GenerateInterfaceCode(string entity, ServiceConfig config) => $@"namespace {config.InterfaceNamespace};

// <auto-generated />
public interface I{entity}Service
{{
    // Define your method here
}}";

    private string GenerateImplCode(string entity, ServiceConfig config) => $@"using {config.InterfaceNamespace};
using {config.RepoInterfaceNamespace};

namespace {config.Namespace};

// <auto-generated />
public class {entity}Service(
    I{entity}Repository repo
) : I{entity}Service
{{
    #region VM/DTO Query Method 
    #endregion
}}";

    private void InjectToDIFile(string filePath, List<string> injectLines, string startMark, string endMark)
    {
        if (!File.Exists(filePath))
        {
            Console.WriteLine($@"DI file not found: {filePath}

Please add:

{startMark}
{endMark}

inside your method for Dependency Injection registration.");
            return;
        }

        var lines = File.ReadAllLines(filePath).ToList();
        var start = lines.FindIndex(l => l.Contains(startMark));
        var end = lines.FindIndex(l => l.Contains(endMark));

        if (start < 0 || end <= start)
        {
            Console.WriteLine($"DI injection markers not found: {startMark} ~ {endMark}");
            return;
        }

        var existing = lines.Skip(start + 1)
                            .Take(end - start - 1)
                            .Where(l => l.Trim().StartsWith("services.AddScoped"))
                            .ToList();

        var merged = existing
            .Concat(injectLines.Where(l => !existing.Any(e => e.Trim() == l.Trim())))
            .Distinct()
            .OrderBy(l => l)
            .ToList();

        lines.RemoveRange(start + 1, end - start - 1);
        lines.InsertRange(start + 1, merged);
        File.WriteAllLines(filePath, lines);

        Console.WriteLine($"Injected {injectLines.Count} services into DI file.");
    }
}

