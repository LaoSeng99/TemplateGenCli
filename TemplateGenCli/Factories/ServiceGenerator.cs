using System.Text;
using TemplateGenCli.Extensions;
using TemplateGenCli.Interfaces;
using TemplateGenCli.Models;

namespace TemplateGenCli.Factories;
public class ServiceGenerator : IGenerator
{
    public void Run(IGeneratorConfig config, GeneratorContext context)
    {
        var svcConfig = (ServiceConfig)config;
        var entityConfig = context.EntityConfig;
        var structureConfig = context.StructureConfig;
        var oriNamespace = svcConfig.Namespace;
        var oriInterfacesNamespace = svcConfig.InterfaceNamespace;
        var oriRepoInterfacesNamespace = svcConfig.RepoInterfaceNamespace;

        if (!Directory.Exists(entityConfig.Path))
        {
            Console.WriteLine($"Entities path not found: {entityConfig.Path}");
            return;
        }

        Directory.CreateDirectory(svcConfig.OutputPath);
        Directory.CreateDirectory(svcConfig.InterfaceOutput);

        if (entityConfig.ExceptEntities.Any(e => e.Contains(" ")))
        {
            Console.WriteLine("Warning: Entity exclusion list may contain invalid names. Make sure they match exact entity class names.");
        }

        var entityFiles = entityConfig.Path.GetEntitiesFilePath(entityConfig.ExceptEntities);
        if (entityFiles.Count == 0)
        {
            Console.WriteLine("No entity files found.");
            return;
        }

        var newInjectLines = new List<string>();
        foreach (var file in entityFiles)
        {
            var entityName = Path.GetFileNameWithoutExtension(file);
            if (string.IsNullOrEmpty(entityName) || string.IsNullOrEmpty(file))
            {
                Console.WriteLine($"Skipping empty file: {file}");
                continue;
            }

            string modularName = "";
            if (structureConfig.Enable)
            {
                modularName = file.GetModularName(structureConfig.ModularAttributeName);
                if (string.IsNullOrEmpty(modularName))
                {
                    Console.WriteLine($"Modular name not found in file: {file}");
                }
                else
                {
                    svcConfig.Namespace = $"{oriNamespace}.{modularName}";
                    svcConfig.InterfaceNamespace = $"{oriInterfacesNamespace}.{modularName}";
                    svcConfig.RepoInterfaceNamespace = $"{oriRepoInterfacesNamespace}.{modularName}";
                    if (structureConfig.ServiceInterfaceModular)
                    {
                        var path = Path.Combine(svcConfig.InterfaceOutput, modularName);
                        Directory.CreateDirectory(path);

                        var outputPath = Path.Combine(svcConfig.OutputPath, modularName);
                        Directory.CreateDirectory(outputPath);
                    }
                }
            }

            var interfaceName = $"I{entityName}Service";
            var className = $"{entityName}Service";

            // 1. Interface
            var interfacePath = Path.Combine(
                svcConfig.InterfaceOutput,
                structureConfig.ServiceInterfaceModular ? modularName : "",
                $"{interfaceName}.cs"
                );

            if (!File.Exists(interfacePath))
            {
                var code = GenerateInterfaceCode(entityName, svcConfig);
                File.WriteAllText(interfacePath, code, Encoding.UTF8);
                Console.WriteLine($"Created: {interfacePath}");
            }

            // 2. Implementation
            var implPath = Path.Combine(
                svcConfig.OutputPath,
                structureConfig.ServiceImplModular ? modularName : "",
                $"{className}.cs"
                );

            if (!File.Exists(implPath))
            {
                var code = GenerateImplCode(entityName, svcConfig);
                File.WriteAllText(implPath, code, Encoding.UTF8);
                Console.WriteLine($"Created: {implPath}");
            }

            // 3. DI Line
            newInjectLines.Add($"        services.AddScoped<{interfaceName}, {className}>();");
        }

        InjectToDIFile(svcConfig.DiFilePath, newInjectLines, svcConfig.StartMark, svcConfig.EndMark);
    }

    private string GenerateInterfaceCode(string entity, ServiceConfig config) => $@"namespace {config.InterfaceNamespace};

// <auto-generated />
public interface I{entity}Service
{{
    // Define your method here
}}";

    private string GenerateImplCode(string entity, ServiceConfig config) => $@"using {config.InterfaceNamespace};
using {config.RepoInterfaceNamespace};

namespace {config.Namespace};

// <auto-generated />
public class {entity}Service(
    I{entity}Repository repo
) : I{entity}Service
{{
    #region DTO Query Method 
    #endregion
}}";

    private void InjectToDIFile(string filePath, List<string> injectLines, string startMark, string endMark)
    {
        if (!File.Exists(filePath))
        {
            Console.WriteLine($@"DI file not found: {filePath}

Please add:

{startMark}
{endMark}

inside your method for Dependency Injection registration.");
            return;
        }

        var lines = File.ReadAllLines(filePath).ToList();
        var start = lines.FindIndex(l => l.Contains(startMark));
        var end = lines.FindIndex(l => l.Contains(endMark));

        if (start < 0 || end <= start)
        {
            Console.WriteLine($"DI injection markers not found: {startMark} ~ {endMark}");
            return;
        }

        var existing = lines.Skip(start + 1)
                            .Take(end - start - 1)
                            .Where(l => l.Trim().StartsWith("services.AddScoped"))
                            .ToList();

        var merged = existing
            .Concat(injectLines.Where(l => !existing.Any(e => e.Trim() == l.Trim())))
            .Distinct()
            .OrderBy(l => l)
            .ToList();

        lines.RemoveRange(start + 1, end - start - 1);
        lines.InsertRange(start + 1, merged);
        File.WriteAllLines(filePath, lines);

        Console.WriteLine($"Injected {injectLines.Count} services into DI file.");
    }
}

